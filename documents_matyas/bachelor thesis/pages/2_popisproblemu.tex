\chapter{Popis problému a specifikace cíle}
\section{Popis problematiky}

Softwarový systém má sloužit člověku k řešení nějakého problému. Uživatel přitom často problém blíže specifikuje a systém musí mít způsob, jak uživateli sdělit jeho řešení. K tomu slouží uživatelská rozhraní, která umožňují vzájemnou komunikaci systému s uživatelem. Uživatelské rozhraní přitom není jednoduchá záležitost. V první řadě by mělo být navrženo tak, aby sloužilo uživateli. Mělo by mu umožnit jednoduchou interakci se systémem, být intuitivní, funkční a hlavně použitelné. 


\subsection{Různá uživatelská rozhraní}
Aby bylo uživatelské rozhraní použitelné a uživatelsky přívětivé je třeba prozkoumat, jakým způsobem člověk s aplikacemi spolupracuje. Nejen tímto se zabývá disciplína zvaná Human Computer Interaction, která zkoumá potřeby uživatelů z různorodých hledisek. Díky této disciplíně vzniklo množství uživatelských rozhraní, pomocí kterých může člověk s počítačem komunikovat. Jedním z takových rozhraní je textové uživatelské rozhraní, značené CUI, jehož typickým zástupcem je příkazová řádka. Dalším typem je Hlasové uživatelské rozhraní, které dokáže interpretovat povely zadané lidskou řečí. Nejrozšířenějším je však grafické uživatelské rozhraní, zkráceně GUI, které využívá grafické prvky. GUI se stalo velmi oblíbeným právě proto, že je jednoduché a grafické prvky v člověku vyvolávají podobnost s vnějším světem. Také není nutné znát žádně specifické příkazy, jako v případě příkazové řádky, nebo hlasové povely jako v případě hlasového rozhraní. Zmínil bych ještě multimodální rozhraní, která používají k interakci více lidských smyslů a tak jsou vhodná například i pro lidi s postižením \cite{uiTypes}. 

V softwarových systémech je nejběžnějsím způsobem interakce uživatele se systémem právě grafické uživatelské rozhraní a tím se taky v této práci zabýváme. Návrh GUI je potřeba důkladně zvážit, neboť závisí na mnoha aspektech. Důležité je, pro jaké zařízení GUI tvoříme, jaký účel má aplikace, která bude rozhraním disponovat a také stav uživatele a prostředí, ve kterém se nachází. Typ zařízení je důležitý hlavně proto, protože každé zařízení používá jiné ovládací prvky. Zatímco u mobilního zařízení můžeme očekávat použití dotykového displeje, u počítače zase použití myši, klávesnice nebo dokonce jiných externích vstupních zařízení, jako může být například grafický tablet. Také je třeba vzít v potaz jinou velikost displeje a jiná rozlišení jednotlivých zařízení. Účel aplikace ovlivňuje GUI hlavně z hlediska obsahu, tedy jaké komponenty je nutné mít, aby byla aplikace využívána k daném účelu. Těžko by asi někdo chtěl emailového klienta bez možnosti odeslat zprávu. Stav uživatele a prostředí může zase ovlivnit způsob ovládání aplikace. Příkladem může být palubní počítač v automobilu, na kterém by měl uživatel být schopen přepnout rádiovou stanici, aniž by se přestal věnovat řízení. 

Co ale takové grafické rozhraní nejčastěji obsahuje? Běžně GUI disponuje ovládacími a vizuálními prvky pomocí kterých lze aplikaci ovládat. Osobně bych GUI prvky rozdělil na vstupní a výstupní. Vstupní prvky zachycují uživatelský vstup a akce, které systém ovládají a výstupní zobrazují uživateli výsledky těchto akcí, data a aktuální stav systému. Vstupními prvky jsou nejčastěji vstupní pole, do kterých může uživatel napsat text, něco zaškrtnout, vybrat mezi možnostmi atp. Takovéto skupině vstupních polí se říká formulář. Systém samozřejmě může pole ve formuláři předvyplnit a z polí tak udělat výstupní prvky, které rovněž budou uživatele informovat o stavu systému. Dalšími vstupními prvky jsou také tlačítka, které provádějí dané akce jako například odeslání formuláře. Výstupními prvky jsou například statické texty, tabulky nebo seznamy položek. 

\subsection{Tvorba uživatelského rozhraní}

Tvorba uživatelského rozhraní není vůbec jednoduchá záležitost. Vývojáři vkládají do tvorby uživatelského rozhraní velké úsilí a značné množství času. Bylo zjištěno, že uživatelské rozhraní zabírá přibližně 48\% kódu aplikace a zhruba 50\% času, který vývoji aplikace věnujeme \cite{towards-smart-design}. Další čas a úsilí také zabere testování rozhraní hlavně z hlediska použitelnosti, které opět stojí spoustu času a nákladů. Například vývojář mnohdy nedokáže odhadnout chování cílové skupiny, která systém bude používat, a tak se často dělají testy s koncovým uživatelem, u kterých se zkoumá, jak daný uživatel software ovládá. Z těchto testů často odhalíme, že uživatelské rozhraní je nedostačující a neposkytuje uživateli komfort při ovládání systému, který by poskystkout mělo. Z vlastní zkušenosti s tímto testem také vím, že velkým problémem je uživatelský vstup, který musí být validován, aby uživatel nevložil data, která jsou v rozporu s modelem, na který je rozhraní namapováno \cite{cernyTEA}. Také je žádoucí zobrazovat uživateli pouze to, co by vidět měl, například na základě jeho uživatelské role v systému. V neposlední řadě je také důležité, jak rozhraní vypadá. Důležitým aspektem rozhraní je, jakým způsobem jsou v něm reprezentována data , a také jak jsou uspořádány jeho jednotlivé části. Z výše uvedeného lze vidět, že je tvorba uživatelského rozhraní opravdu náročný a rozsáhlý proces. Právě proto je poskytovat pro systém více verzí uživatelských rozhraní, například pro různé platformy nebo pro různé uživatelské role, obtížný úkol \cite{cernyTEA}.

Softwarový systém se po nasazení musí také dále udržovat. Ne nadarmo je jedním z hlavních a kritických aspektů dobrého softwaru jeho udržovatelnost, anglicky Maintainability. Udržovatelnost můžeme definovat jako schopnost systému se dále měnit a vyjívet na základě požadavků zákazníka. Změny by přitom měly být lehce proveditelné a něměly by nějak výrazně ovlivnit stav systému. Požadavky na změnu lze očekávat vždy, neboť nevyhnutelně vznikají jako reakce na změny v podnikatelském prostředí (http://faculty.mu.edu.sa/public/uploads/1429431793.203Software%20Engineering%20by%20Somerville.pdf strana 8). Neboli musíme provést změny, jinak nás konkurence předčí. Bohužel však uživatelské rozhraní tuto vlastnost moc nesplňuje. 
Mějme například desktopovou a mobilní aplikaci, které obě obsahují formulář namapovaný na určitou entitu v databázovém modelu. Tento model se nějak změní, například v dané entitě rozdělíme jeden sloupec na dva. Naneštěstí neexistuje žádný machanismus, který by automaticky zaručil, že je UI v souladu s modelem \cite{cernyTEA}. Z pohledu vývojáře to pak znamená, že pokud změní databázový model, musí také změnit uživatelské rozhraní v obou klientských aplikacích, aby korespondovalo s novým databázovým modelem, což je jistá forma typové kontroly. Zde nejenom, že musí vývojář udělat dvakrát stejnou věc, ale také může udělat chybu, což vyústí v nefunkčnost systému. Také pokud se takový formulář vyskytuje třeba na pěti místech v aplikaci, změna je už časově náročnější, hůře proveditelná a ještě více náchylná na chybu vývojáře, který může na nějaký výskyt formuláře zapomenout.
Takovým zásahem do systému nemusí být jen změna databázového modelu, ale také změna validací uživatelského vstupu, které se týkají i bussiness modelu, nebo třeba změna rozložení či pořadí jednotlivých polí ve formuláři.

\subsection{Využití webových služeb pro zisk a odeslání dat}
Jak už bylo řečeno v grafickém uživatelském rozhraní máme výstupní grafické prvky, jako například tabulky či seznamy položek. Tyto komponenty jsou určeny k tomu, aby zobrazovaly uživateli určitá data. Otázkou je odkud se tato data berou. Je hned několik způsobů, kde mohou být data uložena. Jednou z možností je, že má aplikace vlastní databázi. Takováto aplikace není určena k tomu, aby komunikovala nebo sdílela data s dalšími instancemi této aplikace na jiných zařízeních. Pokud komunikaci chceme, je vhodná architektura klient-server. Server může mít vlastní databázi, ze které poskytuje klientům informace například prostřednictvím webových služeb. Webová služba umožňuje jednomu zařízení interakci s jiným zařízením prostřednictvím sítě\cite{wiki-ws}. V tomto případě je jedním zařízením server ,druhým klienstká aplikace a interakcí je myšlen vzájemný přenos dat. V mobilních aplikacích jsou velmi populární interpretací webových služeb RESTful Web Services využívající Representional State Transfer (REST), který byl navržen tak, aby získával data ze zdrojů pomocí jednotných identifikátorů zdrojů (URI), což jsou typicky odkazy na webu. Využívá se právě v aplikacích s klient-server architekturou a ke komunikaci používá HTTP protokol. Výhodou využití HTTP protokolu je, že jeho metody poskytují jednotné rozhraní pro manipulaci se zdroji dat. Http metoda PUT se využívá k vytvoření nového zdroje, DELETE zdroj maže, GET se používá pro získání aktuálního stavu zdroje v nějaké dané reprezentaci a POST stav zdroje upravuje \cite{oracle-ws}. 

Víme tedy, že klient je schopen získat ze serveru data pomocí HTTP dotazu. Aby přijatá data mohl reprezentovat v UI, musí znát jejich strukturu., což by mohl být problém. Naštěstí jsou data ve spojitosti s RESTful službami nejčastěji přenášena ve formě XML nebo alternativně ve formě JSON\cite{ws-formats}. Zmíněné formy dat vzikají serialializací objektů, jejichž definici můžeme většinou získat z dokumentace poskytovatele webové služby, stejně tak jako formát, který pro bude pro serializaci použitý. Je také nutné znát metodu, kterou lze pro využití zdroje použít, popřípadě dodatečné parametry, kterými lze webovou službu nastavit. Tato data na klientovi můžeme zpracovat více způsoby. Jednou z možností je napsat si vlastní parser. Dalším způsobem je využít nějaké knihovny, která umí data sama deserializovat do objektu. Obdobně to funguje i v případě odesílání dat. Zdroj webové služby definuje v jakém formátu data přijme a v dokumentaci opět nalezneme definici objektu, do kterého se bude snažit data deserializovat. Z toho plyne, že klientská aplikace se i při zisku i při odesílání dat musí adaptovat na určitou, předem danou strukturu. Tedy pokud se změní struktura objektu, ze kterého serializací data vznikají a deserializuje se do něj vstup z klienta, je nutné upravit i příslušná místa v klienstké aplikaci, která zpracování a odesílání uživatelského vstupu mají nastarosti.  

Představme si nyní následující problém. Mějme server a na něm model naříklad Tým, který obsahuje dva sloupce - název týmu a počet členů. Vytvoříme si klienstkou aplikaci, která tato data získá a zobrazí, například v tabulce. Nyní se rozhodneme, že by měl přibýt sloupec, obsahující zkratku týmu. Nejdříve se na to podíváme z pohledu zisku dat. Upravíme tedy model na serveru a v datech, která jsou poskytována webovou službou, tedy přibude další hodnota. Proto musíme upravit klientskou aplikaci, aby s těmito dodatečnými daty počítala a rovněž je zobrazila v tabulce. Pokud se však rozhodneme, že se nějaký sloupec odstraní, je situace o trochu složitější. Po získání dat nám na klientovi hodnota bude chybět. Pokud nad hodnotou provádíme nějaké operace a nemáme klienta správně ošetřeného, může to vyústit i v pád aplikace.

Nyní budeme data posílat. Předpokládejme, že jsme ještě neprovedli změny výše a klient je tedy v souladu s modelem na serveru. Je důležité poznamenat, že server může určovat, které hodnoty vyžaduje. Pokud tedy přidáme novou hodnotu, kterou server označí jako povinnou, bude pokus neupraveného klienta zaslat data neúspěšný, neboť je server odmítne. Musíme tedy klienta upravit tak, aby bylo možné novou hodnotu zadat, to znamená přidat nové vstupní pole a upravit parser, či objekt, ze kterého se data připravují serializací na odeslání. Nastane-li odstranění nějakého sloupce z modelu na serveru, bude to pro klienta opět problém, protože bude zasílat data obsahující hodnotu, kterou server nezná a ten data opět odmítne. Znovu je nutné klienta upravit. 

Poznamenejme ještě, že pokaždé, kdy je nutné upravit klienta, se musí vydat nová verze aplikace. Bohužel v dnešní době je možnost aktualizaci neprovést, a to hlavně na mobilních zařízeních, příkladem může být Google Play na Androidu \cite{android-auto-update}. Když si novou verzi člověk nenainstaluje, hrozí tvůrcům buď uživatel s nefunkční aplikací nebo chyba na serveru, záleží na provedené změně. Spousta vývojářů tohle řeší třeba podmínkami na verzi aplikace. Znamená to, že na serveru je stále stará verze modelu, která podporuje starou strukturu dat? Nebo označili na serveru nová pole za nepovinná? Druhým používaným řešením je vynutit aktualizaci aplikace, což se mi zdá jako docela dobré řešení, ale i zde se vyskytují otázky. Co když člověk třeba nemá dostatek mobilních dat na stažení nové verze aplikace? Co když na aktualizaci právě nemá čas? Tento problém bychom eliminovali, pokud by server klienta informoval o tom, co vyžaduje a klient by se dynamicky těmto potřebám přizpůsobil.

\subsection{Existující řešení}
Snažil jsem se najít existující řešení pro mobilní aplikace, které by vytvářelo definici komponenty, například formuláře, na základě modelu a které by pro zisk těchto definic využívalo webových služeb. Bohužel jsem nenašel žádné řešení, které by přesně odpovídalo těmto specifikacím, uvádím však řešení, která řeší alespoň jejich část. Dále pak uvádím projekt AFSwinx \cite{citation-needed}, který sice požadavky splňuje, ale není určen pro mobilní aplikace, nýbrž pro Java SE platformu a AspectFaces \cite{aspect-faces} , z něhož AFSwinx vychází a který je v základu určen pro Java EE aplikace.

\subsubsection{Řešení z IBM developerWorks}
Článek Build dynamic user interfaces with Android and XML \cite{dynamic-android-xml} popisuje možnost dynamického vytvoření formuláře z XML souboru pro Android aplikace. Podle návodu aplikace stáhne z URL adresy určitý XML soubor, ve kterém je nadefinována struktura formuláře. Návod dále ukazuje, jak stažené XML parsovat a dynamicky vytvořit na jeho základě v aplikaci formulář. Tento způsob tedy formulář centralizuje. Pokud se tedy formulář vyskytuje na více místech v aplikaci a je třeba ho změnit, stačí upravit daný XML soubor. Bohužel není XML dokument generován automaticky z modelu a není využito k jeho získání webových služeb, jinak by tento způsob byl pro naše účely řešením. Také je škoda, že na základě návodu nebyla vytvořena žádná knihovna, kterou by Android aplikace mohly používat.

\subsubsection{PHP Database Form}
http://phpdatabaseform.com/
PHP Database Form je rozšíření pro PHP. Toto rozšíření dokáže automaticky z modelu v databázi vytvořit HTML kód formuláře, včetně validací jednotlivých polí. Umožňuje vybrat pro vytvoření pouze některou část tabulky a to pomocí SQL dotazu. Dále pak umožňuje dodatečná nastavení. Lze nastavit názvy polí, jejich viditelnost, dodat validace tam, kde nejsou, nastavit, jak se bude pole zobrazovat atd. Hlavními výhodami tohoto rozšíření jsou: menší množství kódu, jednoduché validování dat a možnost upravit si formulář dle libosti pomocí CSS. Využití vyžaduje PHP verzi 5.3 a Apache, Tomcat nebo Microsoft IIS web server. PHP Database Form podporuje všechny majoritně využívané databáze a webové prohlížeče. Dnes už by se i toto rozšíření dalo použít pro mobilní aplikace, neboť existují možnosti vytvářet multiplatformní mobilní aplikace pomocí HTML, CSS a JavaScriptu, které spouští aplikaci na mobilním zařízení v režimu webového prohlížeče. Takovou možností je například Apache Cordova \cite{apache-cordova}.

\subsubsection{AspectFaces}
AspectFaces je framework, který se snaží o to, aby bylo UI generováno na základě modelu \cite{aspectdriven}, k čemuž využívá inspekci tříd. To umožní nadefinovat UI pouze jednou a veškeré změny v modelu jsou automaticky do uživatelského rozhraní reflektovány. UI lze nadefinovat v modelu pomocí velkého množství anotací z JPA, Hibernate nebo si lze nadefinovat i anotace vlastní. Lze určit například pravidla pro dané pole, pořadí v UI nebo třeba label. Framework zatím poskytuje dynamickou integraci pouze s JavaServer Faces 2.0, ale pracuje se na integraci i s jinými technologiemi. Poslední stabilní verze frameworku je 1.4.0 a je dostupný pod licencí LGPL v3.

\subsubsection{AFSwinx}
TODO citovat bakalářku od Martina
Tento framework byl vytvořen jako koncept a slouží pro generování uživatelského rozhraní v Java SE aplikacích využívajících pro tvorbu UI knihovnu Swing. Tento framework používá RESTful webové služby pro zisk definic komponent, díky kterým je schopen dynamicky postavit formulář či tabulku. Takové definice komponent vznikají za pomocí části frameworku AFRest, která ke generování dat využívá inspekce příslušného modelu na serveru, na který by měla být komponenta namapována. Jelikož se tvoří komponenta na základě tohoto modelu, nenastane tak, že by s ním nebyla v souladu. Inspekci tříd zprostředkovává knihovna AspectFaces, které věnuji samostatný odstavec. Definice komponenty je přenášena ve formátu JSON a obsahuje informace o komponentě, například její rozložení, pole, které má obsahovat nebo pravidla, která pro jednotlivíá pole platí. Pole z definice se v případě formuláře interpretuje jako vstupní políčko, v případě tabulky jako sloupec. 

\subsection{Cíle práce}
TODO citovat Martinovu bakalářku
Vzorem pro tento projekt je výše zmíněný framework AFSwinx. Framework se snaží o zjednodušení tvorby uživatelských rozhraní hlavně z hlediska množství kódu a udržovatelsnosti. Framework na straně serveru využívá inspekce tříd k vytvoření definice modelu, které poskytuje klientovi pomocí webových služeb, stejně tak jako data, kterými se má budoucí komponenta naplnit. Klient tyto informace pouze získává a interpretuje je. Klient také nemá informaci o celém procesu tvorby komponenty, zná pouze nutné informace jako je formát dat, například JSON, XML a připojení. Na vytvoření komponenty stačí klientovi pouze pár řádků kódu. Cílem této práce je vytvořit obdobný framework pro mobilní platformy Android a Windows Phone. Žádoucí je také některé prvky z AFSwinx znovupoužít. Cílem práce je také přinést do stávajícího frameworku něco navíc.
